---
title: "Color Semantics Experiment 1-3 Reanalysis with Linear-Mixed effect Model"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=TRUE,warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(data.table)
library(lmerTest)
library(emmeans)
library(ggplot2)
library(MetBrewer)
library(tidyr)
library(tidyverse)
setwd("/Users/qiawenliu/Downloads/github-archive/data")
data <- fread("/Users/qiawenliu/Downloads/data_plus_predictors 5.tsv")
`%nin%` <- Negate(`%in%`)
data$color_dimension <- paste0(data$color,"_",data$dimension)
# reshape the data
reshaped_data <- data %>%
  mutate(color_dimension = paste0(color, "_", dimension)) %>%
  group_by(pp_id, dimension, color, experiment, color_dimension, sighted) %>%slice(1) %>%  ungroup()
gpt <- fread("/Users/qiawenliu/Box Sync/Research/color_semantics/averaged_gpt.csv")
down_sampled <- fread("/Users/qiawenliu/Downloads/data_plus_predictors_down.tsv")
down_sampled_data <- down_sampled %>%
  mutate(color_dimension = paste0(color, "_", dimension)) %>%
  group_by(pp_id, dimension, color, experiment, color_dimension, sighted) %>%
  slice(1) %>%
  ungroup()
reshaped_data <- merge(reshaped_data,gpt,by=c("color","dimension"),all.x=T)
standardize <- function(x) {
  return((x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE))
}

reshaped_data$gpt_z <- standardize(reshaped_data$gpt)

```

# Experiment 1
```{r}
m1_blind <- lmer(rating_z ~ frequency_z + concreteness_z + cosine_subs_z + swow_all_z + (1 | pp_id) + (1 | color) + (1|dimension),data = reshaped_data %>% filter(experiment=='original',group_eff == -1))

summary(m1_blind)

m1_sighted <- lmer(rating_z ~ frequency_z + concreteness_z + cosine_subs_z + swow_all_z + (1 | pp_id) + (1 | color) + (1|dimension),data = reshaped_data %>% filter(experiment=='original',group_eff == 1))

summary(m1_sighted)

# without swow
m1_blind <- lmer(rating_z ~ frequency_z + concreteness_z + cosine_subs_z + (1 | pp_id) + (1 | color) + (1|dimension),data = reshaped_data %>% filter(experiment=='original',group_eff == -1))

summary(m1_blind)

m1_sighted <- lmer(rating_z ~ frequency_z + concreteness_z + cosine_subs_z + (1 | pp_id) + (1 | color) + (1|dimension),data = reshaped_data %>% filter(experiment=='original',group_eff == 1))

summary(m1_sighted)
```

# Experiment 2
```{r,warning=FALSE}
# Function to extract relevant coefficients with confidence intervals
extract_coef <- function(model, term) {
  coef_summary <- summary(model)$coefficients
  ci <- confint(model, method="Wald")
  
  coef_data <- data.frame(
    term = rownames(coef_summary),
    estimate = coef_summary[, "Estimate"],
    p.value = coef_summary[, "Pr(>|t|)"]
  )
  
  ci_data <- data.frame(
    term = rownames(ci),
    ci_lower = ci[,1],
    ci_upper = ci[,2]
  )
  
  coef_data %>%
    left_join(ci_data, by = "term") %>%
    filter(term == !!term) %>%
    dplyr::select(term, estimate, p.value, ci_lower, ci_upper)
}

results_list <- list()
main_effects <- list()

predictors <- c(
  'cosine_fic_z',
  'cosine_subs_z',
  'cosine_spok_z',
  'cosine_acad_z',
  'cosine_mag_z',
  'cosine_cc_z',
  'cosine_news_z',
  'gpt_z'
)

for (predictor in predictors) {
  predictor_short <- sub("cosine_", "", sub("_z", "", predictor))
  
  # Define models for each predictor
  m2_blind <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z + ", predictor, "+ (1 | pp_id) + (1 | color) + (1 | dimension)"),
                   data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == -1))
  
  m2_sighted <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z +", predictor, "+ (1 | pp_id) + (1 | color) + (1 | dimension)"),
                     data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == 1))
  
  m2_interaction <- lmer(paste("rating_z ~ 1 + group_eff*frequency_z + group_eff*concreteness_z + group_eff*", predictor, "+ (1 | pp_id) + (1 | color) + (1 | dimension)"),
                         data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self')) 
  
  # List of models
  models <- list(
    blind = m2_blind,
    sighted = m2_sighted,
    interaction = m2_interaction
  )
  
  # Extract coefficients for each model
  results <- map2_dfr(models, names(models), ~{
    if (.y == "interaction") {
      rbind(
        extract_coef(.x, paste0("group_eff:", predictor)) %>% mutate(model = .y, effect_type = "interaction"),
        extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
      )
    } else {
      extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
    }
  })
  
  # Reshape the results
  final_results <- results %>%
    mutate(group = case_when(
      model == "blind" ~ "Blind",
      model == "sighted" ~ "Sighted",
      model == "interaction" & effect_type == "interaction" ~ "Interaction",
      model == "interaction" & effect_type == "main" ~ "Main Effect"
    ),
    predictor = predictor_short) %>%
    dplyr::select(predictor, group, estimate, p.value, ci_lower, ci_upper)
  
  results_list[[predictor_short]] <- final_results
  
  # Store main effect for sorting
  main_effects[[predictor_short]] <- final_results %>% 
    filter(group == "Main Effect") %>% 
    pull(estimate)
}


# Combine all results
all_results <- bind_rows(results_list)

# Create a named vector of main effects for sorting
main_effect_values <- unlist(main_effects)
names(main_effect_values) <- names(main_effects)

# Sort predictors by main effect
sorted_predictors <- names(sort(main_effect_values, decreasing = TRUE))

# Add sorting column to all_results
all_results <- all_results %>%
  mutate(sort_order = match(predictor, sorted_predictors))

# Create a named vector for mapping
predictor_names <- c(
  acad = 'COCA-academic',
  news = 'COCA-news',
  spok = 'COCA-spoken',
  mag = 'COCA-magazine',
  cc = 'Common Crawl',
  subs = 'OpenSubtitles',
  fic = 'COCA-fiction',
  gpt = 'GPT4'
)

# Create a dataframe with the main effects for sorting
main_effects <- all_results %>%
  filter(group == "Main Effect") %>%
  dplyr::select(predictor, estimate) %>%
  arrange(desc(estimate))

# Create the ranked order of predictors
predictor_order <- predictor_names[main_effects$predictor]

# Filter out main effect and interaction rows, then reorder factors
plot_data <- all_results %>%
  filter(group %in% c("Sighted", "Blind")) %>%
  mutate(predictor = factor(predictor_names[predictor], levels = predictor_order),
         group = factor(group, levels = c("Sighted", "Blind")))

# Calculate x-axis limits based on the data
x_min <- min(plot_data$ci_lower, na.rm = TRUE)
x_max <- max(plot_data$ci_upper, na.rm = TRUE)
x_range <- x_max - x_min
x_limits <- c(x_min - 0.05 * x_range, x_max + 0.05 * x_range)

ggplot(plot_data, aes(x = estimate, y = predictor, color = group, shape = group)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50", size = 0.5) +
  geom_point(size = 4, position = position_dodge(width = 0.5)) +
  geom_errorbarh(aes(xmin = ci_lower, xmax = ci_upper), height = 0.3, 
                 position = position_dodge(width = 0.5), size = 1, alpha = 0.7) +
  scale_color_manual(values = met.brewer("Lakota", 2)) +
  scale_shape_manual(values = c("Sighted" = 16, "Blind" = 17)) +
  labs(x = "Effect size (standardized coefficient)",
       y = "",
       title = "",
       subtitle = "",
       caption = "") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_blank(),
    legend.background = element_rect(fill = "white", color = NA),
    legend.key = element_rect(fill = NA, color = NA),
    axis.text.y = element_text(hjust = 1),
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12, color = "gray30"),
    plot.caption = element_text(size = 10, color = "gray50"),
    panel.grid.major.x = element_line(color = "gray90"),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_blank(),
    plot.margin = margin(1, 1, 1, 1)
  ) +
  coord_cartesian(clip = "off", xlim = x_limits)
```

## Experiment 2 with alternative random effect structure
```{r}
results_list <- list()
main_effects <- list()

for (predictor in predictors) {
  predictor_short <- sub("cosine_", "", sub("_z", "", predictor))
  
  # Define models for each predictor
  m2_blind <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z + ", predictor, "+ (1 | pp_id) + (1 | color_dimension)"),
                   data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == -1))
  
  m2_sighted <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z +", predictor, "+ (1 | pp_id) + (1 | color_dimension)"),
                     data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == 1))
  
  m2_interaction <- lmer(paste("rating_z ~ 1 + group_eff*frequency_z + group_eff*concreteness_z + group_eff*", predictor, "+ (1 | pp_id) + (1 | color_dimension)"),
                         data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self')) 
  
  # List of models
  models <- list(
    blind = m2_blind,
    sighted = m2_sighted,
    interaction = m2_interaction
  )
  
  # Extract coefficients for each model
  results <- map2_dfr(models, names(models), ~{
    if (.y == "interaction") {
      rbind(
        extract_coef(.x, paste0("group_eff:", predictor)) %>% mutate(model = .y, effect_type = "interaction"),
        extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
      )
    } else {
      extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
    }
  })
  
  # Reshape the results
  final_results <- results %>%
    mutate(group = case_when(
      model == "blind" ~ "Blind",
      model == "sighted" ~ "Sighted",
      model == "interaction" & effect_type == "interaction" ~ "Interaction",
      model == "interaction" & effect_type == "main" ~ "Main Effect"
    ),
    predictor = predictor_short) %>%
    dplyr::select(predictor, group, estimate, p.value, ci_lower, ci_upper)
  
  results_list[[predictor_short]] <- final_results
  
  # Store main effect for sorting
  main_effects[[predictor_short]] <- final_results %>% 
    filter(group == "Main Effect") %>% 
    pull(estimate)
}


# Combine all results
all_results <- bind_rows(results_list)

# Create a named vector of main effects for sorting
main_effect_values <- unlist(main_effects)
names(main_effect_values) <- names(main_effects)

# Sort predictors by main effect
sorted_predictors <- names(sort(main_effect_values, decreasing = TRUE))

# Add sorting column to all_results
all_results <- all_results %>%
  mutate(sort_order = match(predictor, sorted_predictors))

# Create a named vector for mapping
predictor_names <- c(
  acad = 'COCA-academic',
  news = 'COCA-news',
  spok = 'COCA-spoken',
  mag = 'COCA-magazine',
  cc = 'Common Crawl',
  subs = 'OpenSubtitles',
  fic = 'COCA-fiction',
  gpt = 'GPT4'
)

# Create a dataframe with the main effects for sorting
main_effects <- all_results %>%
  filter(group == "Main Effect") %>%
  dplyr::select(predictor, estimate) %>%
  arrange(desc(estimate))

# Create the ranked order of predictors
predictor_order <- predictor_names[main_effects$predictor]

# Filter out main effect and interaction rows, then reorder factors
plot_data <- all_results %>%
  filter(group %in% c("Sighted", "Blind")) %>%
  mutate(predictor = factor(predictor_names[predictor], levels = predictor_order),
         group = factor(group, levels = c("Sighted", "Blind")))

# Calculate x-axis limits based on the data
x_min <- min(plot_data$ci_lower, na.rm = TRUE)
x_max <- max(plot_data$ci_upper, na.rm = TRUE)
x_range <- x_max - x_min
x_limits <- c(x_min - 0.05 * x_range, x_max + 0.05 * x_range)

ggplot(plot_data, aes(x = estimate, y = predictor, color = group, shape = group)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50", size = 0.5) +
  geom_point(size = 4, position = position_dodge(width = 0.5)) +
  geom_errorbarh(aes(xmin = ci_lower, xmax = ci_upper), height = 0.3, 
                 position = position_dodge(width = 0.5), size = 1, alpha = 0.7) +
  scale_color_manual(values = met.brewer("Lakota", 2)) +
  scale_shape_manual(values = c("Sighted" = 16, "Blind" = 17)) +
  labs(x = "Effect size (standardized coefficient)",
       y = "",
       title = "",
       subtitle = "",
       caption = "") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_blank(),
    legend.background = element_rect(fill = "white", color = NA),
    legend.key = element_rect(fill = NA, color = NA),
    axis.text.y = element_text(hjust = 1),
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12, color = "gray30"),
    plot.caption = element_text(size = 10, color = "gray50"),
    panel.grid.major.x = element_line(color = "gray90"),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_blank(),
    plot.margin = margin(1, 1, 1, 1)
  ) +
  coord_cartesian(clip = "off", xlim = x_limits)

```
# Experiment 3
## without downsampling
```{r}
predictors <- c(
  'cosine_fic_z',
  'cosine_fic_no_1st_order_z',
  'cosine_fic_no_neighbors_weak_z',
  'cosine_fic_no_neighbors_strong_z',
  'cosine_fic_no_mediators_z'
)

results_list <- list()
main_effects <- list()

for (predictor in predictors) {
  predictor_short <- sub("cosine_", "", sub("_z", "", predictor))
  
  # Define models for each predictor
  m3_blind <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z +", predictor, "+ (1 | pp_id) + (1 | color) + (1|dimension)"),#
                   data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == -1))
  
  m3_sighted <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z +", predictor, "+ (1 | pp_id) + (1 | color) + (1|dimension)"),
                     data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == 1))
  
  m3_interaction <- lmer(paste("rating_z ~ 1 + group_eff*frequency_z + group_eff*concreteness_z +  group_eff*", predictor, "+ (1 | pp_id) + (1 | color) + (1|dimension)"),#
                         data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self'))
  
  # List of models
  models <- list(
    blind = m3_blind,
    sighted = m3_sighted,
    interaction = m3_interaction
  )
  
  # Extract coefficients for each model
  results <- map2_dfr(models, names(models), ~{
    if (.y == "interaction") {
      rbind(
        extract_coef(.x, paste0("group_eff:", predictor)) %>% mutate(model = .y, effect_type = "interaction"),
        extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
      )
    } else {
      extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
    }
  })
  
  # Reshape the results
  final_results <- results %>%
    mutate(group = case_when(
      model == "blind" ~ "Blind",
      model == "sighted" ~ "Sighted",
      model == "interaction" & effect_type == "interaction" ~ "Interaction",
      model == "interaction" & effect_type == "main" ~ "Main Effect"
    ),
    predictor = predictor_short) %>%
    dplyr::select(predictor, group, estimate, p.value, ci_lower, ci_upper)
  
  results_list[[predictor_short]] <- final_results
  
  # Store main effect for sorting
  main_effects[[predictor_short]] <- final_results %>% 
    filter(group == "Main Effect") %>% 
    pull(estimate)
}

# Combine all results
all_results <- bind_rows(results_list)

# Create a named vector of main effects for sorting
main_effect_values <- unlist(main_effects)
names(main_effect_values) <- names(main_effects)

# Sort predictors by main effect
sorted_predictors <- names(sort(main_effect_values, decreasing = FALSE))

# Add sorting column to all_results
all_results <- all_results %>%
  mutate(sort_order = match(predictor, sorted_predictors))

# View the results
print(all_results)

# Create a named vector for mapping
predictor_names <- c(
  fic = 'COCA-fiction projection',
  fic_no_1st_order = 'COCA-fiction without\n1st order co-occ',
  fic_no_neighbors_weak = 'COCA-fiction without\nneighbors [weak]',
  fic_no_neighbors_strong = 'COCA-fiction without\nneighbors [strong]',
  fic_no_mediators = 'COCA-fiction without\ncommon mediators'
)

# Create a dataframe with the main effects for sorting
main_effects <- all_results %>%
  filter(group == "Main Effect") %>%
  dplyr::select(predictor, estimate) %>%
  arrange(estimate)

# Create the ranked order of predictors
predictor_order <- predictor_names[main_effects$predictor]

# Filter out main effect and interaction rows, then reorder factors
plot_data <- all_results %>%
  filter(group %in% c("Sighted", "Blind")) %>%
  mutate(predictor = factor(predictor_names[predictor], levels = predictor_order),
         group = factor(group, levels = c("Sighted", "Blind")))

# Calculate x-axis limits based on the data
x_min <- min(plot_data$ci_lower, na.rm = TRUE)
x_max <- max(plot_data$ci_upper, na.rm = TRUE)
x_range <- x_max - x_min
x_limits <- c(x_min - 0.02 * x_range, x_max + 0.02 * x_range)

# Create the enhanced plot
ggplot(plot_data, aes(x = estimate, y = predictor, color = group, shape = group)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50", size = 0.5) +
  geom_point(size = 4, position = position_dodge(width = 0.5)) +
  geom_errorbarh(aes(xmin = ci_lower, xmax = ci_upper), height = 0.3, 
                 position = position_dodge(width = 0.5), size = 1, alpha = 0.7) +
  scale_color_manual(values = met.brewer("Lakota", 2)) +
  scale_shape_manual(values = c("Sighted" = 16, "Blind" = 17)) +
  labs(x = "Effect size (standardized coefficient)",
       y = "",
       title = "",
       subtitle = "",
       caption = "") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_blank(),
    legend.margin = margin(0, 0, 0, 0),
    legend.box.margin = margin(0, 0, 0, 0),
    legend.key.size = unit(0.8, "lines"),
    legend.spacing.x = unit(0.2, "cm"),
    axis.text.y = element_text(hjust = 1),
    panel.grid.major.x = element_line(color = "gray90"),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_blank(),
    plot.margin = margin(1, 5, 1, 1),
    axis.title.x = element_text(margin = margin(t = 10))
  )  +
  coord_cartesian(clip = "off", xlim = x_limits)

# Save the plot as PDF
# ggsave("/Users/qiawenliu/Box Sync/Research/color_semantics/perturbed_fiction_projections_plot.pdf", width = 7, height = 5, units = "in", dpi = 300)
```


## alternative random effect structure
```{r}
predictors <- c(
  'cosine_fic_z',
  'cosine_fic_no_1st_order_z',
  'cosine_fic_no_neighbors_weak_z',
  'cosine_fic_no_neighbors_strong_z',
  'cosine_fic_no_mediators_z'
)

results_list <- list()
main_effects <- list()

for (predictor in predictors) {
  predictor_short <- sub("cosine_", "", sub("_z", "", predictor))
  
  # Define models for each predictor
  m3_blind <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z +", predictor, "+ (1 | pp_id) + (1 | color_dimension)"),
                   data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == -1))
  
  m3_sighted <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z +", predictor, "+ (1 | pp_id) + (1 | color_dimension)"),
                     data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == 1))
  
  m3_interaction <- lmer(paste("rating_z ~ 1 + group_eff*frequency_z + group_eff*concreteness_z +  group_eff*", predictor, "+ (1 | pp_id) + (1 | color_dimension)"),#
                         data = subset(reshaped_data, experiment != 'replication_2' & self_vs_other == 'self'))
  
  # List of models
  models <- list(
    blind = m3_blind,
    sighted = m3_sighted,
    interaction = m3_interaction
  )
  
  # Extract coefficients for each model
  results <- map2_dfr(models, names(models), ~{
    if (.y == "interaction") {
      rbind(
        extract_coef(.x, paste0("group_eff:", predictor)) %>% mutate(model = .y, effect_type = "interaction"),
        extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
      )
    } else {
      extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
    }
  })
  
  # Reshape the results
  final_results <- results %>%
    mutate(group = case_when(
      model == "blind" ~ "Blind",
      model == "sighted" ~ "Sighted",
      model == "interaction" & effect_type == "interaction" ~ "Interaction",
      model == "interaction" & effect_type == "main" ~ "Main Effect"
    ),
    predictor = predictor_short) %>%
    dplyr::select(predictor, group, estimate, p.value, ci_lower, ci_upper)
  
  results_list[[predictor_short]] <- final_results
  
  # Store main effect for sorting
  main_effects[[predictor_short]] <- final_results %>% 
    filter(group == "Main Effect") %>% 
    pull(estimate)
}

# Combine all results
all_results <- bind_rows(results_list)

# Create a named vector of main effects for sorting
main_effect_values <- unlist(main_effects)
names(main_effect_values) <- names(main_effects)

# Sort predictors by main effect
sorted_predictors <- names(sort(main_effect_values, decreasing = FALSE))

# Add sorting column to all_results
all_results <- all_results %>%
  mutate(sort_order = match(predictor, sorted_predictors))

# View the results
print(all_results)

# Create a named vector for mapping
predictor_names <- c(
  fic = 'COCA-fiction projection',
  fic_no_1st_order = 'COCA-fiction without\n1st order co-occ',
  fic_no_neighbors_weak = 'COCA-fiction without\nneighbors [weak]',
  fic_no_neighbors_strong = 'COCA-fiction without\nneighbors [strong]',
  fic_no_mediators = 'COCA-fiction without\ncommon mediators'
)

# Create a dataframe with the main effects for sorting
main_effects <- all_results %>%
  filter(group == "Main Effect") %>%
  dplyr::select(predictor, estimate) %>%
  arrange(estimate)

# Create the ranked order of predictors
predictor_order <- predictor_names[main_effects$predictor]

# Filter out main effect and interaction rows, then reorder factors
plot_data <- all_results %>%
  filter(group %in% c("Sighted", "Blind")) %>%
  mutate(predictor = factor(predictor_names[predictor], levels = predictor_order),
         group = factor(group, levels = c("Sighted", "Blind")))

# Calculate x-axis limits based on the data
x_min <- min(plot_data$ci_lower, na.rm = TRUE)
x_max <- max(plot_data$ci_upper, na.rm = TRUE)
x_range <- x_max - x_min
x_limits <- c(x_min - 0.02 * x_range, x_max + 0.02 * x_range)

# Create the enhanced plot
ggplot(plot_data, aes(x = estimate, y = predictor, color = group, shape = group)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50", size = 0.5) +
  geom_point(size = 4, position = position_dodge(width = 0.5)) +
  geom_errorbarh(aes(xmin = ci_lower, xmax = ci_upper), height = 0.3, 
                 position = position_dodge(width = 0.5), size = 1, alpha = 0.7) +
  scale_color_manual(values = met.brewer("Lakota", 2)) +
  scale_shape_manual(values = c("Sighted" = 16, "Blind" = 17)) +
  labs(x = "Effect size (standardized coefficient)",
       y = "",
       title = "",
       subtitle = "",
       caption = "") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_blank(),
    legend.margin = margin(0, 0, 0, 0),
    legend.box.margin = margin(0, 0, 0, 0),
    legend.key.size = unit(0.8, "lines"),
    legend.spacing.x = unit(0.2, "cm"),
    axis.text.y = element_text(hjust = 1),
    panel.grid.major.x = element_line(color = "gray90"),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_blank(),
    plot.margin = margin(1, 5, 1, 1),
    axis.title.x = element_text(margin = margin(t = 10))
  )  +
  coord_cartesian(clip = "off", xlim = x_limits)
```

# Experiment 3
## with downsampling
```{r}
predictors <- c(
  'cosine_fic_z',
  'cosine_fic_no_1st_order_z',
  'cosine_fic_no_neighbors_weak_z',
  'cosine_fic_no_neighbors_strong_z',
  'cosine_fic_no_mediators_z'
)

results_list <- list()
main_effects <- list()

for (predictor in predictors) {
  predictor_short <- sub("cosine_", "", sub("_z", "", predictor))
  
  # Define models for each predictor
  m3_blind <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z +", predictor, "+ (1 | pp_id) + (1 | color) + (1|dimension)"),#
                   data = subset(down_sampled_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == -1))
  
  m3_sighted <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z +", predictor, "+ (1 | pp_id) + (1 | color) + (1|dimension)"),
                     data = subset(down_sampled_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == 1))
  
  m3_interaction <- lmer(paste("rating_z ~ 1 + group_eff*frequency_z + group_eff*concreteness_z +  group_eff*", predictor, "+ (1 | pp_id) + (1 | color) + (1|dimension)"),#
                         data = subset(down_sampled_data, experiment != 'replication_2' & self_vs_other == 'self'))
  
  # List of models
  models <- list(
    blind = m3_blind,
    sighted = m3_sighted,
    interaction = m3_interaction
  )
  
  # Extract coefficients for each model
  results <- map2_dfr(models, names(models), ~{
    if (.y == "interaction") {
      rbind(
        extract_coef(.x, paste0("group_eff:", predictor)) %>% mutate(model = .y, effect_type = "interaction"),
        extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
      )
    } else {
      extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
    }
  })
  
  # Reshape the results
  final_results <- results %>%
    mutate(group = case_when(
      model == "blind" ~ "Blind",
      model == "sighted" ~ "Sighted",
      model == "interaction" & effect_type == "interaction" ~ "Interaction",
      model == "interaction" & effect_type == "main" ~ "Main Effect"
    ),
    predictor = predictor_short) %>%
    dplyr::select(predictor, group, estimate, p.value, ci_lower, ci_upper)
  
  results_list[[predictor_short]] <- final_results
  
  # Store main effect for sorting
  main_effects[[predictor_short]] <- final_results %>% 
    filter(group == "Main Effect") %>% 
    pull(estimate)
}

# Combine all results
all_results <- bind_rows(results_list)

# Create a named vector of main effects for sorting
main_effect_values <- unlist(main_effects)
names(main_effect_values) <- names(main_effects)

# Sort predictors by main effect
sorted_predictors <- names(sort(main_effect_values, decreasing = FALSE))

# Add sorting column to all_results
all_results <- all_results %>%
  mutate(sort_order = match(predictor, sorted_predictors))

# View the results
print(all_results)

# Create a named vector for mapping
predictor_names <- c(
  fic = 'COCA-fiction projection',
  fic_no_1st_order = 'COCA-fiction without\n1st order co-occ',
  fic_no_neighbors_weak = 'COCA-fiction without\nneighbors [weak]',
  fic_no_neighbors_strong = 'COCA-fiction without\nneighbors [strong]',
  fic_no_mediators = 'COCA-fiction without\ncommon mediators'
)

# Create a dataframe with the main effects for sorting
main_effects <- all_results %>%
  filter(group == "Main Effect") %>%
  dplyr::select(predictor, estimate) %>%
  arrange(estimate)

# Create the ranked order of predictors
predictor_order <- predictor_names[main_effects$predictor]

# Filter out main effect and interaction rows, then reorder factors
plot_data <- all_results %>%
  filter(group %in% c("Sighted", "Blind")) %>%
  mutate(predictor = factor(predictor_names[predictor], levels = predictor_order),
         group = factor(group, levels = c("Sighted", "Blind")))

# Calculate x-axis limits based on the data
x_min <- min(plot_data$ci_lower, na.rm = TRUE)
x_max <- max(plot_data$ci_upper, na.rm = TRUE)
x_range <- x_max - x_min
x_limits <- c(x_min - 0.02 * x_range, x_max + 0.02 * x_range)

# Create the enhanced plot
ggplot(plot_data, aes(x = estimate, y = predictor, color = group, shape = group)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50", size = 0.5) +
  geom_point(size = 4, position = position_dodge(width = 0.5)) +
  geom_errorbarh(aes(xmin = ci_lower, xmax = ci_upper), height = 0.3, 
                 position = position_dodge(width = 0.5), size = 1, alpha = 0.7) +
  scale_color_manual(values = met.brewer("Lakota", 2)) +
  scale_shape_manual(values = c("Sighted" = 16, "Blind" = 17)) +
  labs(x = "Effect size (standardized coefficient)",
       y = "",
       title = "",
       subtitle = "",
       caption = "") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_blank(),
    legend.margin = margin(0, 0, 0, 0),
    legend.box.margin = margin(0, 0, 0, 0),
    legend.key.size = unit(0.8, "lines"),
    legend.spacing.x = unit(0.2, "cm"),
    axis.text.y = element_text(hjust = 1),
    panel.grid.major.x = element_line(color = "gray90"),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_blank(),
    plot.margin = margin(1, 5, 1, 1),
    axis.title.x = element_text(margin = margin(t = 10))
  )  +
  coord_cartesian(clip = "off", xlim = x_limits)
```


## alternative random effect structure with downsampling
```{r}
predictors <- c(
  'cosine_fic_z',
  'cosine_fic_no_1st_order_z',
  'cosine_fic_no_neighbors_weak_z',
  'cosine_fic_no_neighbors_strong_z',
  'cosine_fic_no_mediators_z'
)

results_list <- list()
main_effects <- list()

for (predictor in predictors) {
  predictor_short <- sub("cosine_", "", sub("_z", "", predictor))
  
  # Define models for each predictor
  m3_blind <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z +", predictor, "+ (1 | pp_id) + (1 | color_dimension)"),
                   data = subset(down_sampled_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == -1))
  
  m3_sighted <- lmer(paste("rating_z ~ 1 + frequency_z + concreteness_z +", predictor, "+ (1 | pp_id) + (1 | color_dimension)"),
                     data = subset(down_sampled_data, experiment != 'replication_2' & self_vs_other == 'self') %>% filter(group_eff == 1))
  
  m3_interaction <- lmer(paste("rating_z ~ 1 + group_eff*frequency_z + group_eff*concreteness_z +  group_eff*", predictor, "+ (1 | pp_id) + (1 | color_dimension)"),
                         data = subset(down_sampled_data, experiment != 'replication_2' & self_vs_other == 'self'))
  
  # List of models
  models <- list(
    blind = m3_blind,
    sighted = m3_sighted,
    interaction = m3_interaction
  )
  
  # Extract coefficients for each model
  results <- map2_dfr(models, names(models), ~{
    if (.y == "interaction") {
      rbind(
        extract_coef(.x, paste0("group_eff:", predictor)) %>% mutate(model = .y, effect_type = "interaction"),
        extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
      )
    } else {
      extract_coef(.x, predictor) %>% mutate(model = .y, effect_type = "main")
    }
  })
  
  # Reshape the results
  final_results <- results %>%
    mutate(group = case_when(
      model == "blind" ~ "Blind",
      model == "sighted" ~ "Sighted",
      model == "interaction" & effect_type == "interaction" ~ "Interaction",
      model == "interaction" & effect_type == "main" ~ "Main Effect"
    ),
    predictor = predictor_short) %>%
    dplyr::select(predictor, group, estimate, p.value, ci_lower, ci_upper)
  
  results_list[[predictor_short]] <- final_results
  
  # Store main effect for sorting
  main_effects[[predictor_short]] <- final_results %>% 
    filter(group == "Main Effect") %>% 
    pull(estimate)
}

# Combine all results
all_results <- bind_rows(results_list)

# Create a named vector of main effects for sorting
main_effect_values <- unlist(main_effects)
names(main_effect_values) <- names(main_effects)

# Sort predictors by main effect
sorted_predictors <- names(sort(main_effect_values, decreasing = FALSE))

# Add sorting column to all_results
all_results <- all_results %>%
  mutate(sort_order = match(predictor, sorted_predictors))

# View the results
print(all_results)

# Create a named vector for mapping
predictor_names <- c(
  fic = 'COCA-fiction projection',
  fic_no_1st_order = 'COCA-fiction without\n1st order co-occ',
  fic_no_neighbors_weak = 'COCA-fiction without\nneighbors [weak]',
  fic_no_neighbors_strong = 'COCA-fiction without\nneighbors [strong]',
  fic_no_mediators = 'COCA-fiction without\ncommon mediators'
)

# Create a dataframe with the main effects for sorting
main_effects <- all_results %>%
  filter(group == "Main Effect") %>%
  dplyr::select(predictor, estimate) %>%
  arrange(estimate)

# Create the ranked order of predictors
predictor_order <- predictor_names[main_effects$predictor]

# Filter out main effect and interaction rows, then reorder factors
plot_data <- all_results %>%
  filter(group %in% c("Sighted", "Blind")) %>%
  mutate(predictor = factor(predictor_names[predictor], levels = predictor_order),
         group = factor(group, levels = c("Sighted", "Blind")))

# Calculate x-axis limits based on the data
x_min <- min(plot_data$ci_lower, na.rm = TRUE)
x_max <- max(plot_data$ci_upper, na.rm = TRUE)
x_range <- x_max - x_min
x_limits <- c(x_min - 0.02 * x_range, x_max + 0.02 * x_range)

# Create the enhanced plot
ggplot(plot_data, aes(x = estimate, y = predictor, color = group, shape = group)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50", size = 0.5) +
  geom_point(size = 4, position = position_dodge(width = 0.5)) +
  geom_errorbarh(aes(xmin = ci_lower, xmax = ci_upper), height = 0.3, 
                 position = position_dodge(width = 0.5), size = 1, alpha = 0.7) +
  scale_color_manual(values = met.brewer("Lakota", 2)) +
  scale_shape_manual(values = c("Sighted" = 16, "Blind" = 17)) +
  labs(x = "Effect size (standardized coefficient)",
       y = "",
       title = "",
       subtitle = "",
       caption = "") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "top",
    legend.title = element_blank(),
    legend.margin = margin(0, 0, 0, 0),
    legend.box.margin = margin(0, 0, 0, 0),
    legend.key.size = unit(0.8, "lines"),
    legend.spacing.x = unit(0.2, "cm"),
    axis.text.y = element_text(hjust = 1),
    panel.grid.major.x = element_line(color = "gray90"),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_blank(),
    plot.margin = margin(1, 5, 1, 1),
    axis.title.x = element_text(margin = margin(t = 10))
  )  +
  coord_cartesian(clip = "off", xlim = x_limits)
```


# Conditional probability (P(color|adjective) as an alternative predictor for color-adjective association
```{r}
m_cond_blind <- lmer(rating_z ~ frequency_z + concreteness_z + cosine_fic_z + cond_prob_diff_coca_fict + (1 | pp_id) + (1 | color) + (1|dimension),data = reshaped_data %>% filter(experiment=='original',group_eff == -1))

summary(m_cond_blind)

m_cond_sighted <- lmer(rating_z ~ frequency_z + concreteness_z + cosine_fic_z + cond_prob_diff_coca_fict + (1 | pp_id) + (1 | color) + (1|dimension),data = reshaped_data %>% filter(experiment=='original',group_eff == 1))

summary(m_cond_sighted)

```

